# Copyright (C) 2025 VD_Priv8 (VD171)
# This code is licensed under GNU AGPLv3 (https://www.gnu.org/licenses/agpl-3.0.html).
# See the LICENSE file for details.

import argparse, os, re, shutil, subprocess

INFO = {
    "version": "1.0",
    "author": "VD_Priv8 (VD171)",
    "github": "https://github.com/VD171",
    "telegram": "https://t.me/VD_Priv8"
}

def main():
    vd_parser = argparse.ArgumentParser(epilog=f"KeyBox Generator v{INFO['version']} by {INFO['author']}\nGitHub: {INFO['github']}\nTelegram: {INFO['telegram']}\n ", formatter_class=argparse.RawDescriptionHelpFormatter)
    vd_parser.add_argument("--file", default="keybox.xml", help="Keybox file path")
    vd_parser.add_argument("--title", default="New certificate generated by @VD_Priv8", help="Title for the new certificate")
    vd_parser.add_argument("--serial", default="VDPriv8", help="Serial for the new certificate")
    vd_parser.add_argument("--out", default="keybox.new.xml", help="New Keybox file path")
    vd_args = vd_parser.parse_args()

    if not shutil.which("openssl"):  
        exit("Error: OpenSSL not found! Try running in Termux!")

    vd_temp_key = ".temp.private.key"
    vd_temp_cert = ".temp.certificate.pem"
    vd_temp_new_key = ".temp.new.private.key"
    vd_temp_new_csr = ".temp.new.certificate.csr"

    if not os.path.exists(vd_args.file):
        exit(f"Error: File '{vd_args.file}' not found! Use: --file")

    with open(vd_args.file, encoding="utf-8") as f:
        vd_content = f.read()

    vd_key = re.search(r"<PrivateKey format=\"pem\">(.*?)</PrivateKey>", vd_content, re.DOTALL)
    vd_cert = re.search(r"(<Certificate format=\"pem\">(.*?)</Certificate>)", vd_content, re.DOTALL)
    vd_number = re.search(r"(<NumberOfCertificates>(.*?)</NumberOfCertificates>)", vd_content, re.DOTALL)
    
    if not all([vd_key, vd_cert, vd_number]):
        exit("Error: Missing required elements!")
    
    for vd_temp, vd_data in {vd_temp_key: vd_key.group(1), vd_temp_cert: vd_cert.group(2)}.items():
        with open(vd_temp, "w") as f:
            f.write(vd_data)
        if not os.path.exists(vd_temp):
            exit(f"Error: Can't create {vd_temp}!")
    
    vd_new_key = subprocess.run("openssl ecparam -name prime256v1 -genkey", shell=True, capture_output=True, text=True).stdout.strip()
    vd_new_key = re.search(r"(-----BEGIN EC PRIVATE KEY-----.*?-----END EC PRIVATE KEY-----)", vd_new_key, re.DOTALL).group(1)
    
    with open(vd_temp_new_key, "w") as f:
        f.write(vd_new_key)
    if not os.path.exists(vd_temp_new_key):
        exit(f"Error: Can't create {vd_temp_new_key}!")
    
    subprocess.run(f"openssl req -new -key {vd_temp_new_key} -out {vd_temp_new_csr} -subj '/title={vd_args.title}/serialNumber={vd_args.serial}'", shell=True)
    vd_new_cert = subprocess.run(f"openssl x509 -req -in {vd_temp_new_csr} -CA {vd_temp_cert} -CAkey {vd_temp_key} -CAcreateserial -days 365 -sha256", shell=True, capture_output=True, text=True).stdout.strip()
    
    vd_number_new = vd_number.group(1).replace(vd_number.group(2), str(int(vd_number.group(2)) + 1))
    vd_cert_new = vd_cert.group(1).replace(vd_cert.group(2), vd_new_cert) + "\n" + vd_cert.group(1)
    
    with open(vd_args.out, "w") as f:
        f.write(vd_content.replace(vd_number.group(1), vd_number_new).replace(vd_key.group(1), vd_new_key).replace(vd_cert.group(1), vd_cert_new))
    
    print(f"New keybox: {vd_args.out}.")
    for vd_temp in [vd_temp_key, vd_temp_cert, vd_temp_new_key, vd_temp_new_csr, ".temp.certificate.srl"]:
        os.remove(vd_temp)

if __name__ == "__main__":
    main()
